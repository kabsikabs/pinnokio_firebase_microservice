# üìä Rapport d√©taill√© : Gestion de la Workflow Checklist

## 1. üîÑ Mise √† jour des donn√©es

### 1.1 Flux de donn√©es complet

```
üì° RTDB Firebase
    ‚Üì
    [Message type='CMMD']
    ‚Üì
üì® handle_realtime_message() (ligne 20840)
    ‚Üì
    [D√©tection message_type == 'CMMD']
    ‚Üì
üìã Parsing du message (ligne 21004-21060)
    ‚Üì
    [Extraction de action et params]
    ‚Üì
üéØ Dispatch selon action:
    ‚îú‚îÄ "SET_WORKFLOW_CHECKLIST" ‚Üí Initialisation compl√®te
    ‚îî‚îÄ "UPDATE_STEP_STATUS" ‚Üí Mise √† jour d'une √©tape
    ‚Üì
üíæ Mise √† jour de ChatState.workflow_checklist
    ‚Üì
üé® Re-render automatique du composant
```

### 1.2 Code de r√©ception des mises √† jour

**Localisation** : `base_state.py`, ligne 21004-21060

```python
elif message_type == 'CMMD':
    try:
        content_str = message_data.get('content', '{}')
        content = json.loads(content_str)
        
        # Extract command data
        cmmd = content.get("message", {}).get("cmmd", {})
        action = cmmd.get("action", "")
        params = cmmd.get("params", {})
        
        print(f"Processing command: action={action}, params={params}")
        
        # Handle different command actions
        if action == "SET_PROCESS_STATE":
            # Update router_process_running state
            new_state = params.get("state", False)
            self.onboarding_job_active = new_state
            print(f"Updated chatsate command to: False\nvaleur onborading job: True")

        elif action == "SET_WORKFLOW_CHECKLIST":
            # üîß INITIALISATION COMPL√àTE DE LA CHECKLIST
            checklist_data = params.get("checklist", {})
            self.workflow_checklist = checklist_data
            self.checklist_visible = True
            print(f"‚úÖ Checklist du workflow mise √† jour: {checklist_data.get('total_steps', 0)} √©tapes")

        elif action == "UPDATE_STEP_STATUS":
            # üîÑ MISE √Ä JOUR D'UNE √âTAPE SP√âCIFIQUE
            if self.workflow_checklist:
                step_id = params.get("step_id")
                new_status = params.get("status")
                timestamp = params.get("timestamp")
                message = params.get("message")

                # Trouver et mettre √† jour l'√©tape correspondante
                for step in self.workflow_checklist.get("steps", []):
                    if step.get("id") == step_id:
                        step["status"] = new_status
                        step["timestamp"] = timestamp
                        if message:
                            step["message"] = message
                        break

                print(f"üìä √âtape {step_id} mise √† jour: {new_status}")
        
        # ‚úÖ CORRECTION : Forcer un yield pour d√©clencher la r√©activit√© UI
        yield
        
    except json.JSONDecodeError as e:
        print(f"Error parsing command JSON: {e}")
```

## 2. üì¶ Structure des donn√©es

### 2.1 Format du message RTDB entrant

```json
{
  "type": "CMMD",
  "content": "{\"message\": {\"cmmd\": {\"action\": \"SET_WORKFLOW_CHECKLIST\", \"params\": {...}}}}",
  "timestamp": "2025-01-21T10:30:00Z",
  "sender_id": "system",
  "message_type": "CMMD"
}
```

### 2.2 Structure de `SET_WORKFLOW_CHECKLIST`

```python
{
    "action": "SET_WORKFLOW_CHECKLIST",
    "params": {
        "checklist": {
            "total_steps": 8,
            "steps": [
                {
                    "id": "DOCUMENT_EXTRACTION",
                    "name": "Document Analysis",
                    "status": "completed",  # "pending", "in_progress", "completed", "error"
                    "timestamp": "2025-01-21T10:30:00Z",
                    "message": "Document extracted successfully"
                },
                {
                    "id": "ROUTE_DEFINITION",
                    "name": "Document Routing Validation",
                    "status": "in_progress",
                    "timestamp": "2025-01-21T10:31:00Z",
                    "message": ""
                },
                # ... autres √©tapes
            ]
        }
    }
}
```

### 2.3 Structure de `UPDATE_STEP_STATUS`

```python
{
    "action": "UPDATE_STEP_STATUS",
    "params": {
        "step_id": "ROUTE_DEFINITION",  # ID de l'√©tape √† mettre √† jour
        "status": "completed",           # Nouveau statut
        "timestamp": "2025-01-21T10:32:00Z",
        "message": "Route validated"     # Message optionnel
    }
}
```

## 3. üéß Configuration de l'√©coute RTDB/Firebase

### 3.1 Initialisation du listener

**Localisation** : `base_state.py`, ligne 20356-20445

```python
@rx.event(background=True)
async def start_realtime_listener(self):
    """
    üéß D√©marre l'√©couteur pour les messages Firebase Realtime via le gestionnaire unifi√©.
    """
    async with self:
        try:
            # V√©rification des pr√©requis
            if not (self.companies_search_id and self.current_chat):
                print("[CHAT_LISTENERS] ‚ùå Impossible de d√©marrer l'√©couteur")
                return

            # üìã R√©cup√©rer le mode Firebase depuis personal_chats
            mode = 'chats'  # Valeur par d√©faut
            for chat_info in self.personal_chats:
                if chat_info.get("thread_key") == self.current_chat:
                    mode = chat_info.get("mode", "chats")
                    print(f"[CHAT_LISTENERS] üîç Mode Firebase trouv√©: {mode}")
                    break
            
            print(f"[CHAT_LISTENERS] üöÄ D√©marrage √©couteur pour {self.companies_search_id}/{self.current_chat}")
            print(f"[CHAT_LISTENERS]    - chat_mode: {self.chat_mode}")
            print(f"[CHAT_LISTENERS]    - listener_mode: {mode}")

            # D√©marrer via le gestionnaire unifi√©
            from ..listeners.manager import listener_manager
            main_loop = asyncio.get_running_loop()
            
            async def handler(message_data: dict):
                # handle_realtime_message retourne un async generator
                async for _ in self.handle_realtime_message(message_data):
                    pass  # Consommer le generator
            
            await listener_manager.start_chat_listener(
                space_code=self.companies_search_id,  # ‚Üê ID de l'entreprise
                thread_key=self.current_chat,         # ‚Üê ID du chat/thread
                user_id=self.firebase_user_id,        # ‚Üê ID de l'utilisateur
                main_loop=main_loop,
                handler=handler,
                mode=mode,                             # ‚Üê Mode Firebase ('chats' ou 'job_chats')
                chat_mode=self.chat_mode,              # ‚Üê Mode de chat ('onboarding_chat', etc.)
            )

            # M√©moriser les informations
            self.chat_space_code = self.companies_search_id
            self.chat_thread_key = self.current_chat
            self.Chat_realtime_listener_active = True
            
            print(f"[CHAT_LISTENERS] ‚úÖ √âcouteur Realtime d√©marr√© avec succ√®s")
            
        except Exception as e:
            print(f"[CHAT_LISTENERS] ‚ùå Erreur: {e}")
            self.Chat_realtime_listener_active = False
```

### 3.2 Chemin d'√©coute Firebase Realtime Database

**Structure du chemin** :
```
/clients/{firebase_user_id}/{mode}/{space_code}/threads/{thread_key}/messages
```

**Exemple concret** :
```
/clients/user123/chats/katalog_demo_12345/threads/onboarding_1758614588/messages
```

**Param√®tres** :
- `firebase_user_id` : ID de l'utilisateur Firebase
- `mode` : `'chats'` (chats utilisateur) ou `'job_chats'` (chats de jobs)
- `space_code` : ID de l'entreprise (= `companies_search_id`)
- `thread_key` : ID du thread de chat (= `current_chat`)

### 3.3 Filtrage des messages

**Localisation** : `base_state.py`, ligne 20869-20884

```python
# üõ°Ô∏è GUARD D√âFENSIF : Filtrer les messages RTDB pour general_chat avec microservice
if self.chat_mode == 'general_chat' and self._is_microservice_mode_active():
    # Accepter : llm_stream_* + √©v√©nements agentiques + √©v√©nements de cartes
    agentic_events = ['tool_use_start', 'tool_use_complete']
    card_events = ['CARD', 'CARD_CLICKED_PINNOKIO']
    allowed_events = agentic_events + card_events
    
    if message_type and not message_type.startswith('llm_stream_') and message_type not in allowed_events:
        return  # Ignorer les messages RTDB

# ‚úÖ Pour onboarding_chat, TOUS les messages sont accept√©s, y compris 'CMMD'
```

**üí° Important** : Les messages de type `'CMMD'` sont **toujours accept√©s** en mode `onboarding_chat`.

## 4. ‚ö° R√®gles pour la r√©activit√©

### 4.1 M√©canisme de r√©activit√© Reflex

```python
# ‚úÖ Variables r√©actives dans ChatState
workflow_checklist: Optional[Dict[str, List[Dict[str, Any]]]] = None  # Mutable
checklist_visible: bool = False                                         # Mutable

# ‚úÖ Variable calcul√©e (se met √† jour automatiquement)
@rx.var
def workflow_checklist_steps(self) -> List[Dict[str, Any]]:
    if not self.workflow_checklist or not self.workflow_checklist.get("steps"):
        return []
    return self.workflow_checklist["steps"]

# ‚úÖ Variable calcul√©e pour la progression
@rx.var
def workflow_progress_percentage(self) -> int:
    if not self.workflow_checklist or not self.workflow_checklist.get("steps"):
        return 0
    
    steps = self.workflow_checklist["steps"]
    completed_steps = sum(1 for step in steps if step.get("status") == "completed")
    total_steps = len(steps)
    
    if total_steps == 0:
        return 0
    
    return int((completed_steps / total_steps) * 100)
```

### 4.2 D√©clenchement du re-render

**üîß CRITIQUE** : Le `yield` √† la fin du traitement de `CMMD` (ligne 21057)

```python
elif message_type == 'CMMD':
    try:
        # ... traitement des actions SET_WORKFLOW_CHECKLIST et UPDATE_STEP_STATUS
        
        # ‚úÖ CORRECTION : Forcer un yield pour d√©clencher la r√©activit√© UI
        yield  # ‚Üê INDISPENSABLE pour le re-render
        
    except json.JSONDecodeError as e:
        print(f"Error parsing command JSON: {e}")
```

**Sans ce `yield`** :
- ‚ùå Les modifications de `workflow_checklist` ne d√©clenchent pas de re-render
- ‚ùå L'UI ne se met pas √† jour automatiquement
- ‚ùå L'utilisateur ne voit pas les changements

**Avec ce `yield`** :
- ‚úÖ Reflex d√©tecte que l'√©tat a chang√©
- ‚úÖ Les variables calcul√©es (`workflow_checklist_steps`, `workflow_progress_percentage`) sont recalcul√©es
- ‚úÖ Le composant `workflow_checklist_component()` se re-render automatiquement
- ‚úÖ L'UI refl√®te instantan√©ment les changements

### 4.3 Utilisation de `rx.foreach` pour la r√©activit√©

```python
# Ligne 75-116 dans index.py
rx.foreach(
    ChatState.workflow_checklist_steps,  # ‚Üê Variable calcul√©e r√©active
    lambda step: rx.hstack(
        # ... affichage de chaque √©tape
    )
)
```

**Avantages de `rx.foreach`** :
- ‚úÖ Re-render automatique quand `workflow_checklist_steps` change
- ‚úÖ Optimisation : seules les √©tapes modifi√©es sont re-render
- ‚úÖ Type-safe avec la variable calcul√©e

## 5. üéØ Conditions d'affichage du composant

### 5.1 Condition principale de visibilit√©

**Localisation** : `index.py`, ligne 61-145

```python
def workflow_checklist_component() -> rx.Component:
    """Composant pour afficher la checklist du workflow d'onboarding."""
    return rx.cond(
        ChatState.checklist_visible,  # ‚Üê Condition principale
        # ... contenu si visible
        rx.box()  # Placeholder vide si non visible
    )
```

### 5.2 R√®gles de visibilit√© de `checklist_visible`

**üìç Activation de la checklist** :

#### A. Via `check_onboarding_job_status()` (ligne 18777-18843)

```python
@rx.event(background=True)
async def check_onboarding_job_status(self):
    """V√©rifie l'√©tat du job d'onboarding et met √† jour les variables d'√©tat."""
    try:
        # Lecture du document onboarding dans Firebase
        firebase_c = FireBaseManagement()
        data = firebase_c.get_document(document_path=onboarding_path) or {}
        job_active_remote = bool(data.get('job_active', False))
        
        if company_name and company_name == self.companies_search_term:
            # üìã GESTION DE LA CHECKLIST selon le statut du job
            if job_active_remote:
                # Job actif ‚Üí rendre la checklist visible
                if not self.checklist_visible:
                    self.checklist_visible = True  # ‚úÖ ACTIVATION
                    print("üìã Checklist rendue visible (job actif)")
            else:
                # Job inactif ‚Üí masquer la checklist
                self.checklist_visible = False  # ‚ùå D√âSACTIVATION
                self.workflow_checklist = None
                print("üìã Checklist masqu√©e (job inactif)")
        else:
            # Pas de donn√©es d'onboarding
            self.checklist_visible = False  # ‚ùå D√âSACTIVATION
            self.workflow_checklist = None
```

#### B. Via `SET_WORKFLOW_CHECKLIST` (ligne 21027-21032)

```python
elif action == "SET_WORKFLOW_CHECKLIST":
    # Initialisation de la checklist
    checklist_data = params.get("checklist", {})
    self.workflow_checklist = checklist_data
    self.checklist_visible = True  # ‚úÖ ACTIVATION AUTOMATIQUE
    print(f"‚úÖ Checklist du workflow mise √† jour")
```

#### C. Via `toggle_onboarding_job()` - Arr√™t du job (ligne 18897-18909)

```python
if result.get('success', False):
    # Arr√™t r√©ussi du job
    self.onboarding_job_active = False
    
    # üßπ SUPPRIMER LA CHECKLIST quand le job est arr√™t√©
    self.workflow_checklist = None
    self.checklist_visible = False  # ‚ùå D√âSACTIVATION
    print("üßπ Checklist du workflow supprim√©e (job arr√™t√©)")
```

### 5.3 Table de d√©cision pour l'affichage

| Condition | `checklist_visible` | Affichage |
|-----------|---------------------|-----------|
| `onboarding_job_active == True` | `True` | ‚úÖ Visible |
| `onboarding_job_active == False` | `False` | ‚ùå Masqu√© |
| Message `SET_WORKFLOW_CHECKLIST` re√ßu | `True` | ‚úÖ Visible |
| Job arr√™t√© manuellement | `False` | ‚ùå Masqu√© |
| Pas de donn√©es d'onboarding | `False` | ‚ùå Masqu√© |
| `workflow_checklist == None` | N/A | ‚ùå Masqu√© |

### 5.4 Int√©gration dans l'onglet Jobs

**Localisation** : `index.py`, ligne 147-434

```python
def job_tab() -> rx.Component:
    """Composant pour l'onglet Jobs qui affiche les jobs disponibles."""
    return rx.vstack(
        rx.heading("Jobs", size="3", margin_bottom="4"),
        
        # Section Onboarding
        rx.cond(
            ChatState.job_tab_active,  # ‚Üê Job tab doit √™tre actif
            rx.card(
                rx.vstack(
                    # ... En-t√™te avec bouton Start/Stop
                    
                    # üìã CHECKLIST DU WORKFLOW
                    workflow_checklist_component(),  # ‚Üê Insertion du composant
                    
                    # ... Autres sections
                )
            )
        )
    )
```

## 6. üîç Conditions compl√®tes pour l'affichage

### 6.1 Cha√Æne de conditions

```
Pour que la checklist soit visible, il faut :

1. job_tab_active == True
   ‚îî‚îÄ Activ√© via check_onboarding_job_status()
   ‚îî‚îÄ Condition : donn√©es d'onboarding trouv√©es pour l'entreprise

2. checklist_visible == True
   ‚îî‚îÄ Activ√© via :
      ‚îú‚îÄ check_onboarding_job_status() si job_active == True
      ‚îú‚îÄ SET_WORKFLOW_CHECKLIST re√ßu via RTDB
      ‚îî‚îÄ initialize_onboarding_chat() lors du d√©marrage

3. workflow_checklist != None
   ‚îî‚îÄ Initialis√© via SET_WORKFLOW_CHECKLIST

4. Chat_realtime_listener_active == True
   ‚îî‚îÄ Listener RTDB actif pour recevoir les mises √† jour
```

### 6.2 Code de v√©rification

**Dans `ChatState`** :

```python
# V√©rification rapide de l'√©tat
print(f"job_tab_active: {self.job_tab_active}")
print(f"checklist_visible: {self.checklist_visible}")
print(f"workflow_checklist: {self.workflow_checklist is not None}")
print(f"Chat_realtime_listener_active: {self.Chat_realtime_listener_active}")
print(f"onboarding_job_active: {self.onboarding_job_active}")
```

## 7. üìù R√©sum√© de la configuration

### 7.1 Variables d'√©tat critiques

| Variable | Type | R√¥le |
|----------|------|------|
| `workflow_checklist` | `Dict` | Donn√©es de la checklist |
| `checklist_visible` | `bool` | Visibilit√© du composant |
| `workflow_checklist_steps` | `List` | Variable calcul√©e pour l'affichage |
| `workflow_progress_percentage` | `int` | Pourcentage calcul√© |
| `onboarding_job_active` | `bool` | Statut du job |
| `job_tab_active` | `bool` | Visibilit√© de l'onglet Jobs |

### 7.2 Actions RTDB support√©es

| Action | Effet | Param√®tres requis |
|--------|-------|-------------------|
| `SET_WORKFLOW_CHECKLIST` | Initialisation compl√®te | `checklist` (dict) |
| `UPDATE_STEP_STATUS` | Mise √† jour d'une √©tape | `step_id`, `status`, `timestamp`, `message` |
| `SET_PROCESS_STATE` | Activation/d√©sactivation du job | `state` (bool) |

### 7.3 Chemins d'√©coute Firebase

```
Format g√©n√©ral :
/clients/{user_id}/{mode}/{space_code}/threads/{thread_key}/messages

Pour onboarding :
/clients/{firebase_user_id}/chats/{companies_search_id}/threads/{current_chat}/messages
```

## 8. üêõ Points de d√©bogage

### 8.1 Checklist de d√©pannage

‚úÖ **V√©rifier l'√©coute RTDB** :
```python
print(f"Listener actif: {ChatState.Chat_realtime_listener_active}")
print(f"Space code: {ChatState.chat_space_code}")
print(f"Thread key: {ChatState.chat_thread_key}")
```

‚úÖ **V√©rifier les donn√©es** :
```python
print(f"Checklist visible: {ChatState.checklist_visible}")
print(f"Checklist data: {ChatState.workflow_checklist}")
print(f"Steps count: {len(ChatState.workflow_checklist_steps)}")
```

‚úÖ **V√©rifier le job** :
```python
print(f"Job tab actif: {ChatState.job_tab_active}")
print(f"Job actif: {ChatState.onboarding_job_active}")
print(f"Mode chat: {ChatState.chat_mode}")
```

### 8.2 Probl√®mes courants

| Probl√®me | Cause | Solution |
|----------|-------|----------|
| Checklist ne s'affiche pas | `checklist_visible == False` | V√©rifier `check_onboarding_job_status()` |
| Pas de mises √† jour | Listener inactif | V√©rifier `start_realtime_listener()` |
| Donn√©es non mises √† jour | Pas de `yield` apr√®s modification | Ajouter `yield` apr√®s les modifications |
| Mauvais chemin RTDB | `mode` incorrect | V√©rifier `mode` dans `personal_chats` |

---

**‚úÖ Ce rapport couvre tous les aspects de la gestion de la workflow checklist dans l'application Pinnokio.**